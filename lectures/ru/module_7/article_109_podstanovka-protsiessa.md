Подстановка процесса <(команда), >(команда)


Вы найдете два вида синтаксиса для замены процесса:  
<(commands) или >(commands)  
Вы обнаружите, что замена процесса может использоваться аналогично перенаправлению STDOUT или STDIN.  
Оператором <(commands) вы читаете замену. Это означает, что commands настроена на использование как stdout.  
Например, следующая команда использует вывод ls \*sh:  
`wc -l <(ls \*sh)`  
Это эквивалентно:  
`ls \*sh | wc -l`  
Оператором С >(commands) вы пишете на замену. Это означает, что commands настроена на использование как stdin.  
Другими словами, когда у вас есть команда, которая выводит данные в файл, но вы хотите, чтобы она записывалась в какую-то другую команду вместо файла.  
Пример, который должен прояснить ситуацию:  
`tar -cf >(ssh remote\_server tar xf -)`  
Вы только что перенесли все содержимое текущего каталога на удаленный сервер. Файл архива создается на лету и распаковывается на сервере.  
Если честно, оператор >(…) встречается реже. Вы обнаружите, что <(…) можно использовать чаще.  
Итак, в чем преимущество подстановки процессов, если она работает как обычное перенаправление ввода-вывода?  
Вы поймете силу и полезность подстановки процессов bash, когда у вас есть несколько командных конвейеров, которые можно объединить в одну команду.  
Наиболее очевидное и наиболее частое использование подмены процесса – это сравнение результатов двух программ. Позвольте показать вам это на практическом примере.  
Допустим, у вас есть файлы программы Java и соответствующие им объектные файлы (файл .class) с тем же именем в каталоге.  
Вот ваша цель. Вы хотите проверить, имеет ли каждый файл Java соответствующий выходной файл с тем же именем, что и файл Java.  
Ваш типичный подход – перечислить файлы, отфильтрованные по расширению, а затем использовать команду cut с разделителем. (Точка), чтобы извлечь имя файла без расширения:  
`ls \*.c | cut -d. -f1`  
Ваш типичный подход – сохранить вывод файлов \* .c и \* .out во временные файлы, а затем сравнить эти файлы с помощью команды diff  
`ls \*.c | cut -d. -f1 > c.txt`  
`ls \*.out | cut -d. -f1 > out.txt`  
`diff c.txt out.txt`  
`rm c.txt out.txt`  
Вы можете использовать каталог /tmp для создания временных файлов, но у вас все еще есть три строки команд.  
Вы можете красиво использовать подстановку процесса, чтобы заменить все вышеперечисленное одной командой без создания временных файлов:  
`diff <(ls \*.c | cut -d. -f1) <(ls \*.out | cut -d. -f1)`  
Вам не нужно было создавать здесь какие-либо временные файлы, и это главное. Вот наш совет о том, когда следует использовать замену процесса.  
Каждый раз, когда вы думаете, что вам нужен временный файл для чего-то, подумайте, можно ли использовать замену процесса.


Заглянем немного под капот: Подстановка процессов позволяет интерпретировать вывод подоболочки как  
обычный файл и осуществлять его перенаправление. Так как это форма подстановки, всегда можно узнать действительное подставляемое значение:  
`[me@linuxbox ~]$ echo <(echo "foo")`  
/dev/fd/63  
Вывод результата подстановки командой echo показывает, что вывод подоболочки передается через файл с именем /dev/fd/63.

