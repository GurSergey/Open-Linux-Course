подстановка переменной $переменная или ${переменная} присваивание значений переменным производится так:  
переменная=значение  
где переменная — это имя переменной, а значение — строка. В отличие от некоторых других языков программирования, командная оболочка не заботится о типах значений, присваиваемых переменным; она все значения интерпретирует как строки. Существует возможность заставить командную оболочку ограничить круг  
присваиваемых значений целыми числами, задействовав команду declare с параметром -i, но, как и объявление переменных, доступных только для чтения, эта возможность редко используется на практике.  
Обратите внимание на отсутствие пробелов в операторе присваивания между именем переменной, знаком «равно» и значением. А из чего может состоять значение? Из всего что угодно, что можно развернуть в строку.  
**a=c** # Присвоит переменной a строку "c".  
**b="a string"** # Внутренние пробелы должны находиться в кавычках.  
**c="a string and $b"** # При присваивании допускается выполнять подстановку,  
# например, значений других переменных.  
**d=$(ls -l foo.txt)** # Результат выполнения команды.  
**e=$((5 \* 7))** # Подстановка результата арифметического выражения.  
**f="\t\ta string\n"** # Экранированные последовательности, такие как символы табуляции и перевода строки.  
В одной строке можно выполнить присваивание сразу нескольким переменным:  
a=5 b="a string"  
При использовании подстановки имена переменных можно заключать в необязательные фигурные скобки {}. Это пригодится в том случае, когда имя переменной становится неоднозначным в окружающем контексте. В следующем примере выполняется попытка переименовать файл myfile в myfile1 с использованием переменной:  
`[me@linuxbox ~]$ filename="myfile"`  
`[me@linuxbox ~]$ touch $filename`  
`[me@linuxbox ~]$ mv $filename $filename1`  
Эта попытка не увенчалась успехом, потому что командная оболочка интерпретировала второй аргумент команды mv как имя новой (и пустой) переменной. Ниже показано, как решается подобная проблема:  
`[me@linuxbox ~]$ mv $filename ${filename}1`  
Добавив фигурные скобки, мы гарантировали, что командная оболочка не будет интерпретировать последний символ 1 как часть имени переменной.

