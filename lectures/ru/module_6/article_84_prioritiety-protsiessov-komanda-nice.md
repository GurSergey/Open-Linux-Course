Переключение центрального процессора между задачами (процессами и нитями) выполняет специальная компонента подсистемы управления процессами, называе­мая планировщиком (scheduler). Именно планировщик определенным образом выбирает из множества неспящих, готовых к выполнению (runable) задач одну, которую переводит в состояние выполнения (running). Процедуры, определяющие способ выбора и моменты выполнения выбора, называются алгоритмами планиро­вания. Выбор задачи, подлежащей выполнению, естественным образом происходит в моменты времени, когда текущая выполнявшаяся задача переходит в состояние  
сна (sleep) в результате выполнения операции ввода-вывода. Вытесняющие алго­ритмы планирования, кроме всего прочего, ограничивают непрерывное время вы­полнения задачи, принудительно прерывая ее выполнение по исчерпанию выданно­го ей кванта времени (timeslice) и вытесняя ее во множество готовых, после чего  
производят выбор новой задачи, подлежащей выполнению.  
По умолчанию для пользовательских задач используется вытесняющий алгоритм CFS (completely fair scheduler), согласно которому процессорное время распределя­ется между неспящими задачами справедливым (fair) образом. Для каждой задачи определяется выделяемая справедливая (в соответствии с ее относительным «при­оритетом») доля процессорного времени, которую она должна получить при конку­ренции за процессор. Для двух задач с любыми одинаковыми приоритетами долж­ны быть выделены равные доли (в 50% процессорного времени), а при различии в приоритетах на одну ступень разница между выделяемыми долями должна составить «10% процессорного времени (т. е. 55 и 45% соответственно). Для удовлетворения этого требования алгоритм планирования CFS назначает каждой ступени приоритета соответствующий вес задачи, а процессорное время делит ме­жду всеми неспящими задачами пропорционально их весам.  
Для дифференциации задач используют 40 относительных POSIX-приоритетов на шкале от —20 до +19, называемых «любезностью» задачи NICE. Относительный приоритет буквально определяет, насколько «любезна» будет задача по отношению к остальным готовым к выполнению задачам при конкуренции за процессорное  
время освободившегося процессора. Наименее «любезным», с относительным при­оритетом —20 (наивысшим) планировщик выделит большую долю процессорного времени, а наиболее «любезным», с приоритетом +19 (наинизшим) — меньшую.  
При отсутствии конкуренции, когда количество готовых к выполнению задач равно количеству свободных процессоров, приоритет не будет играть никакой роли.


Проиллюстрировать действие относительного приоритета NICE на многопроцессор­ной системе можно, создав искусственную конкуренцию двух процессов за один процессор. Для этого при помощи команды taskset устанавливается привязка (affinity) командного интерпретатора (смотрим с помощью команды ps) к процессору 3 (привязка, как и прочие свойства и атрибуты процесса, наследуется потомками). Затем при по­мощи команды nice запускаются два скрипта python [buble\_sort.py](../files/buble_sort.py "buble_sort.py") с относительными приоритетами 5 и 20. В результате доли процессорного времени распределяются нерав­номерно, причем их разница зависит от разницы в относительных приоритетах (и от свойств конкурирующих процессов, но в примере они одинаковые). Дождав­шись завершения процессов заднего фона, в конце скрипт выводит время в течении которого он выполнялся


`ps fo pid,pcpu,pri,ni,psr,cmd` 

PID %CPU PRI  NI PSR CMD   
 12583  0.2  19   0   0 /bin/zsh


 


`taskset -p -c 3 12583`


pid 12583's current affinity list: 0   
pid 12583's new affinity list: 3


 


`nice --adjustment=20 python3 buble\_sort.py &`


`nice --adjustment=5 python3 buble\_sort.py &`


 


--- 8.542015790939331 seconds ---  
[2]  + done       nice --adjustment=5 python3 buble\_sort.py  



--- 14.143185377120972 seconds ---  
[1]  + done       nice --adjustment=20 python3 buble\_sort.py  
  


