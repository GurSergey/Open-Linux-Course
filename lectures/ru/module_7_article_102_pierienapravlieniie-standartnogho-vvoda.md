До сих пор нам не встречались команды, использующие стандартный ввод (на самом деле они встречались, но мы подробнее обсудим их чуть ниже), поэтому нам нужно познакомиться с ними.


Команда cat читает содержимое одного или нескольких файлов и копирует его в стандартный вывод:  
`cat [файл...]`  
Часто команду cat можно считать аналогом команды TYPE в DOS. Она используется для вывода содержимого файлов без возможности постраничного просмотра.  
Например,  
`[me@linuxbox ~]$ cat ls-output.txt`  
выведет содержимое файла ls-output.txt. Команда cat часто используется для вывода коротких текстовых файлов. Поскольку cat способна принимать сразу несколько файлов, она используется для их объединения. Представьте, что вы загрузили большой файл, разбитый на множество частей, и требуется объединить их в один файл. Если файлы имеют имена, такие как  
text.txt.001 text.txt.002 ... text.txt.099  
их можно объединить следующей командой:  
`[me@linuxbox ~]$ cat text.txt.0\* > text.txt`


Поскольку подстановка фактических имен взамен групповых символов всегда выполняется в порядке сортировки, аргументы окажутся расположенными в правильном порядке.  
Все это прекрасно, но при чем здесь стандартный ввод? Пока ни при чем, но давайте попробуем кое-что еще. Что получится, если вызвать cat без аргументов?  
`[me@linuxbox ~]$ cat`  
Ничего не произошло — такое ощущение, что команда зависла. Однако в действительности команда делает именно то, что и предполагалось.  
Если вызвать cat без аргументов, она начнет читать данные со стандартного ввода, а поскольку стандартный ввод по умолчанию подключен к клавиатуре, получается, что команда ждет, пока вы что-нибудь напечатаете!  
Попробуйте так:  
`[me@linuxbox ~]$ cat`  
Съешь ещё этих мягких французских булок, да выпей чаю.  
Затем нажмите комбинацию CTRL-D (то есть, удерживая нажатой клавишу CTRL, нажмите клавишу D), чтобы сообщить команде cat, что достигнут конец файла (end-of-file, EOF) на стандартном вводе:  
`[me@linuxbox ~]$ cat`  
Съешь ещё этих мягких французских булок, да выпей чаю.  
Съешь ещё этих мягких французских булок, да выпей чаю.  
В отсутствие аргументов с именами файлов cat копирует содержимое стандартного ввода в стандартный вывод, поэтому-то мы и увидели, как она повторила введенную нами строку. Эту ее особенность можно использовать для создания коротких текстовых файлов. Представьте, что вам потребовалось создать файл с именем eat\_more.txt, содержащий текст из примера, приведенного выше. Сделать это можно было бы так:  
`[me@linuxbox ~]$ cat > eat\_more.txt`  
Съешь ещё этих мягких французских булок, да выпей чаю.  
Введите команду, затем текст, который нужно поместить в файл, и не забудьте нажать комбинацию CTRL-D в конце. Используя командную строку, мы реализовали самый простой в мире текстовый процессор! Чтобы увидеть результат, воспользуемся командой cat и скопируем файл в стандартный вывод:  
`[me@linuxbox ~]$ cat eat\_more.txt`  
Съешь ещё этих мягких французских булок, да выпей чаю.  
Теперь, когда мы знаем, что команда cat может принимать данные не только из файлов, указанных в аргументах, но и со стандартного ввода, попробуем выполнить перенаправление стандартного ввода:  
`[me@linuxbox ~]$ cat < eat\_more.txt`  
Съешь ещё этих мягких французских булок, да выпей чаю.  
Используя оператор перенаправления <, мы изменили источник данных для стандартного ввода с клавиатуры на файл eat\_more.txt. Как видите, результат получился тот же, как если бы мы просто передали единственный аргумент с именем файла. Этот способ не имеет никаких преимуществ в сравнении с передачей простого  
аргумента, но он демонстрирует, как можно использовать файлы в роли источника данных для стандартного ввода. Другие команды находят лучшее применение стандартному вводу, в чем мы вскоре убедимся.

